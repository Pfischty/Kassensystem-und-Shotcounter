{% extends "base.html" %}
{% block title %}Admin{% endblock %}
{% block content %}
<h1>Adminbereich</h1>

<style>
  .muted { color: #94a3b8; font-size: 0.95rem; }
  .event-card { background: #0b1222; border: 1px solid rgba(255,255,255,0.05); }
  .hint { font-size:0.9rem; color:#cbd5e1; margin-top:0.2rem; }
  .stack { display:flex; flex-direction:column; gap:0.35rem; }
  .field-inline { display:flex; gap:0.6rem; flex-wrap:wrap; align-items:center; }
  .collapsible { border: 1px solid var(--border); border-radius: 12px; overflow: hidden; }
  .collapsible__header { display:flex; justify-content:space-between; align-items:center; gap:0.8rem; padding: 0.75rem 1rem; background: rgba(255,255,255,0.04); }
  .collapsible__content { padding: 1rem; border-top: 1px solid var(--border); background: rgba(255,255,255,0.02); }
  .collapsible [data-toggle] { min-width: 130px; }
  .inline-actions { display:flex; gap:0.4rem; flex-wrap:wrap; align-items:center; }
  .product-editor {
    margin-top: 0.6rem;
    border: 1px dashed var(--border);
    border-radius: 10px;
    padding: 0.9rem;
    background: rgba(255,255,255,0.02);
  }
  .product-editor__top { display:flex; align-items:center; justify-content:space-between; gap:0.6rem; flex-wrap:wrap; }
  .product-editor__preview {
    margin-top: 0.8rem;
    display: grid;
    gap: 0.6rem;
    grid-template-columns: repeat(auto-fill, minmax(150px, 1fr));
  }
  .product-preview-card {
    border-radius: 12px;
    padding: 0.85rem;
    color: #e2e8f0;
    box-shadow: 0 10px 30px rgba(0,0,0,0.25);
    border: 1px solid rgba(255,255,255,0.08);
    cursor: grab;
    transition: transform 0.15s ease, box-shadow 0.2s ease;
  }
  .product-preview-card small { opacity: 0.75; display:block; margin-bottom:0.35rem; }
  .product-preview-card.dragging { opacity: 0.6; transform: scale(0.98); }
  .product-preview-card.drag-over { outline: 2px dashed rgba(255,255,255,0.5); }
  .product-editor__list { margin-top: 1rem; display:flex; flex-direction:column; gap:0.75rem; }
  .product-row {
    display:grid;
    grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
    gap:0.6rem;
    background:#0c1324;
    border:1px solid var(--border);
    border-radius:10px;
    padding:0.75rem;
  }
  .product-row label { font-size: 0.9rem; color: #cbd5e1; display:block; margin-bottom:0.2rem; }
  .product-row .row-actions { display:flex; justify-content:flex-end; align-items:flex-end; }
  .product-row .row-actions button { width:100%; }
  .color-input { width:100%; min-height:44px; padding: 0; }
  .pill { padding: 0.3rem 0.7rem; border-radius: 999px; background: rgba(255,255,255,0.06); border: 1px solid var(--border); font-size: 0.9rem; }
  .shot-settings { margin: 0.8rem 0; }
  .shot-settings__grid { display:grid; grid-template-columns: repeat(auto-fit, minmax(180px, 1fr)); gap:0.6rem; margin-top: 0.4rem; }
  .shot-settings__grid span { font-size: 0.9rem; color: #cbd5e1; }
  .shot-settings__numbers { display:grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap:0.6rem; margin-top: 0.6rem; }
  .badge-yellow { background: rgba(245, 158, 11, 0.2); color: #f59e0b; border: 1px solid rgba(245,158,11,0.5); }
  
  /* Modal/Popup Styles */
  .modal {
    display: none;
    position: fixed;
    z-index: 1000;
    left: 0;
    top: 0;
    width: 100%;
    height: 100%;
    overflow: auto;
    background-color: rgba(0, 0, 0, 0.7);
    animation: fadeIn 0.2s ease;
  }
  .modal.active {
    display: flex;
    align-items: center;
    justify-content: center;
  }
  .modal-content {
    background: #0b1222;
    border: 1px solid rgba(255,255,255,0.1);
    border-radius: 16px;
    padding: 2rem;
    max-width: 900px;
    width: 90%;
    max-height: 90vh;
    overflow-y: auto;
    position: relative;
    animation: slideIn 0.3s ease;
    box-shadow: 0 20px 60px rgba(0,0,0,0.5);
  }
  .modal-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 1.5rem;
    padding-bottom: 1rem;
    border-bottom: 1px solid var(--border);
  }
  .modal-header h2 {
    margin: 0;
    font-size: 1.5rem;
  }
  .modal-close {
    background: transparent;
    border: none;
    font-size: 2rem;
    color: #94a3b8;
    cursor: pointer;
    padding: 0;
    width: 40px;
    height: 40px;
    display: flex;
    align-items: center;
    justify-content: center;
    border-radius: 8px;
    transition: background 0.2s ease, color 0.2s ease;
  }
  .modal-close:hover {
    background: rgba(255,255,255,0.1);
    color: #fff;
  }
  @keyframes fadeIn {
    from { opacity: 0; }
    to { opacity: 1; }
  }
  @keyframes slideIn {
    from { transform: translateY(-20px); opacity: 0; }
    to { transform: translateY(0); opacity: 1; }
  }
  
  /* Status toggle button */
  .status-toggle {
    min-width: 130px;
  }
  .status-toggle.active {
    background: rgba(34, 197, 94, 0.2);
    color: #22c55e;
    border-color: rgba(34, 197, 94, 0.5);
  }
  .status-toggle.inactive {
    background: rgba(239, 68, 68, 0.2);
    color: #ef4444;
    border-color: rgba(239, 68, 68, 0.5);
  }
  .status-toggle.archived {
    background: rgba(100, 116, 139, 0.2);
    color: #94a3b8;
    border-color: rgba(100, 116, 139, 0.5);
  }
  
  /* Prevent body scroll when modal is open */
  body.modal-open {
    overflow: hidden;
  }
</style>

<!-- Events Section (moved to top) -->
<div class="card">
  <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 1rem;">
    <h2 style="margin: 0;">Events</h2>
    <button type="button" class="primary" id="new-event-btn">+ Neues Event</button>
  </div>
  {% if not events %}
    <p>Es wurden noch keine Events angelegt.</p>
  {% endif %}
  {% for event in events %}
    <div class="event-card" style="margin-bottom: 1rem;" data-event-card="{{ event.id }}">
      <div style="display: flex; justify-content: space-between; align-items: center; padding: 0.75rem 1rem;">
        <div>
          <strong>{{ event.name }}</strong>
          {% if event.is_active %}<span class="badge badge-green">aktiv</span>{% endif %}
          {% if event.is_archived %}<span class="badge badge-red">archiviert</span>{% endif %}
          <div class="muted">Letzte Änderung: {{ event.updated_at.strftime("%d.%m.%Y %H:%M") if event.updated_at else "–" }}</div>
        </div>
        <div class="inline-actions">
          <form class="inline" method="post" action="{{ url_for('activate_event', event_id=event.id) if (event.is_archived or not event.is_active) else url_for('archive_event', event_id=event.id) }}">
            <button type="submit" class="status-toggle {% if event.is_active %}active{% elif event.is_archived %}archived{% else %}inactive{% endif %}">
              {% if event.is_archived %}
                Archiviert - Aktivieren
              {% elif event.is_active %}
                Aktiv - Archivieren
              {% else %}
                Inaktiv - Aktivieren
              {% endif %}
            </button>
          </form>
          <button type="button" class="secondary" data-event-settings="{{ event.id }}">Einstellungen</button>
        </div>
      </div>
    </div>
  {% endfor %}
</div>

<!-- Modal for New Event -->
<div id="new-event-modal" class="modal">
  <div class="modal-content">
    <div class="modal-header">
      <h2>Neues Event anlegen</h2>
      <button type="button" class="modal-close" data-close-modal="new-event-modal">&times;</button>
    </div>
    <form method="post" action="{{ url_for('create_event') }}" data-event-form data-scope="new">
      <div class="stack">
        <label for="name">Name</label>
        <input id="name" name="name" placeholder="z.B. Sommerfest" required>
      </div>
      <div class="field-inline" style="margin: 0.6rem 0;">
        <label><input type="checkbox" name="kassensystem_enabled" checked> Kassensystem aktiv</label>
        <label><input type="checkbox" name="shotcounter_enabled" checked> Shotcounter aktiv</label>
      </div>
      <div class="field-inline" style="margin: 0.6rem 0;">
        <label><input type="checkbox" name="auto_reload_on_add" checked data-shared-setting> Auto-Reload beim Hinzufügen (Kasse)</label>
      </div>
      <div class="muted" style="margin-bottom: 0.6rem;">Wenn deaktiviert, wird die Kasse nicht neu geladen beim Hinzufügen von Artikeln (performanter).</div>
      {% if events %}
      <div class="stack" style="margin: 0.6rem 0;">
        <label>Vorlage kopieren</label>
        <div class="field-inline">
          <select data-copy-select>
            <option value="">Bitte wählen</option>
            {% for template in events %}
              <option value="{{ template.id }}">{{ template.name }}</option>
            {% endfor %}
          </select>
          <button type="button" class="secondary" data-copy-btn>Übernehmen</button>
        </div>
        <div class="muted">Übernimmt Einstellungen, Shotcounter-Optionen und Kassenartikel der gewählten Vorlage.</div>
      </div>
      {% endif %}

      <input type="hidden" name="shared_settings" value='{}'>

      <div
        class="shot-settings"
        data-shot-settings
        data-defaults='{{ shotcounter_defaults | tojson }}'
        data-current='{{ shotcounter_defaults | tojson }}'
      >
        <strong>Shotcounter Styling</strong>
        <div class="muted">Farben, Schriftgrößen und Anzahl Teams im Vollbild.</div>
        <div class="shot-settings__grid">
          <label class="stack">
            <span>Hintergrund</span>
            <input type="color" class="color-input" data-shot-field="background_color">
          </label>
          <label class="stack">
            <span>Primärfarbe (Karten)</span>
            <input type="color" class="color-input" data-shot-field="primary_color">
          </label>
          <label class="stack">
            <span>Sekundärfarbe (Verlauf)</span>
            <input type="color" class="color-input" data-shot-field="secondary_color">
          </label>
          <label class="stack">
            <span>Terziärfarbe (Verlauf)</span>
            <input type="color" class="color-input" data-shot-field="tertiary_color">
          </label>
        </div>
        <div class="shot-settings__numbers">
          <label class="stack">
            <span>Schriftgröße Titel (rem)</span>
            <input type="number" step="0.1" min="0.5" max="10" data-shot-field="title_size">
          </label>
          <label class="stack">
            <span>Schriftgröße Teams (rem)</span>
            <input type="number" step="0.1" min="0.5" max="10" data-shot-field="team_size">
          </label>
          <label class="stack">
            <span>Teams im Leaderboard</span>
            <input type="number" step="1" min="1" max="50" data-shot-field="leaderboard_limit">
          </label>
        </div>
        <div class="shot-settings__numbers" style="margin-top: 0.6rem;">
          <label class="stack">
            <span>Leaderboard Layout</span>
            <select data-shot-field="leaderboard_layout">
              <option value="stacked">Teamname + Shots (2 Zeilen)</option>
              <option value="inline">Teamname – Shots (1 Zeile)</option>
            </select>
          </label>
        </div>
        <input type="hidden" name="shotcounter_settings" value='{{ shotcounter_defaults | tojson }}'>
      </div>

      <input type="hidden" name="kassensystem_settings" value='{{ {"items": default_buttons} | tojson }}'>
      <p class="hint">Kassenartikel lassen sich nach dem Speichern oder per Vorlage übernehmen.</p>
      <div class="field-inline">
        <label class="secondary" style="padding:0.45rem 0.65rem; cursor:pointer;">
          Event-JSON importieren
          <input type="file" accept="application/json" data-import-event hidden>
        </label>
        <button type="button" class="secondary" data-export-event>Event-JSON exportieren</button>
      </div>
      <div class="form-actions" style="margin-top: 1rem;">
        <button type="submit" class="primary" data-submit-btn>Event anlegen</button>
        <span class="form-status" data-form-status style="margin-left: 0.8rem; color: #94a3b8; display: none;"></span>
      </div>
    </form>
  </div>
</div>

<!-- Credentials Management Section -->
<div class="collapsible card" data-collapsible>
  <div class="collapsible__header">
    <div>
      <h2 style="margin:0;">Admin-Zugangsdaten</h2>
      <div class="muted">Benutzername und Passwort für den Admin-Bereich verwalten.</div>
    </div>
    <button type="button" class="secondary" data-toggle>Details einblenden</button>
  </div>
  <div class="collapsible__content" hidden>
    <form method="post" action="{{ url_for('update_credentials') }}" data-credentials-form data-has-password="{{ 'true' if has_password else 'false' }}">
      <div class="stack">
        <label for="admin_username">Benutzername</label>
        <input 
          id="admin_username" 
          name="admin_username" 
          type="text"
          value="{% if admin_username %}{{ admin_username }}{% endif %}" 
          placeholder="admin" 
          required
        >
        <div class="hint">Der Benutzername für die Admin-Authentifizierung.</div>
      </div>
      
      <div class="stack" style="margin-top: 1rem;">
        <label for="admin_password">Passwort</label>
        <input 
          id="admin_password" 
          name="admin_password" 
          type="password"
          placeholder="Neues Passwort (mind. 8 Zeichen)"
        >
        <div class="hint">
          {% if has_password %}
            Leer lassen, um das aktuelle Passwort beizubehalten.
          {% else %}
            Setzen Sie ein Passwort, um den Admin-Bereich zu schützen.
          {% endif %}
        </div>
      </div>

      <div class="field-inline" style="margin-top: 1rem;">
        <button type="submit">Zugangsdaten speichern</button>
      </div>
      <div class="flash error" data-credentials-error style="display:none; margin-top: 1rem;"></div>
      
      <div class="muted" style="margin-top: 1rem;">
        <strong>Hinweis:</strong> Die Zugangsdaten werden in der Datei <code>instance/credentials.json</code> gespeichert, 
        die nicht ins Git-Repository übernommen wird. {% if not has_password %}
        Solange kein Passwort gesetzt ist, ist der Admin-Bereich ohne Authentifizierung zugänglich.
        {% endif %}
      </div>
    </form>
  </div>
</div>

<!-- Network Management Section -->
<div class="collapsible card" data-collapsible>
  <div class="collapsible__header">
    <div>
      <h2 style="margin:0;">Netzwerkeinstellungen</h2>
      <div class="muted">LAN (eth0) und WLAN (wlan0) Schnittstellen verwalten.</div>
    </div>
    <button type="button" class="secondary" data-toggle>Details einblenden</button>
  </div>
  <div class="collapsible__content" hidden>
    <div id="network-status">
      <p class="muted">Lade Netzwerkinformationen...</p>
    </div>
  </div>
</div>

<!-- System Update Section -->
<div class="collapsible card" data-collapsible>
  <div class="collapsible__header">
    <div>
      <h2 style="margin:0;">System-Update</h2>
      <div class="muted">Git-Repository aktualisieren und Service neu starten.</div>
    </div>
    <button type="button" class="secondary" data-toggle>Details einblenden</button>
  </div>
  <div class="collapsible__content" hidden>
    <div id="git-status">
      <p class="muted">Lade Git-Informationen...</p>
    </div>
  </div>
</div>

<!-- Modals for Event Settings (one for each event, generated dynamically) -->
{% for event in events %}
<div id="event-modal-{{ event.id }}" class="modal">
  <div class="modal-content">
    <div class="modal-header">
      <h2>{{ event.name }} - Einstellungen</h2>
      <button type="button" class="modal-close" data-close-modal="event-modal-{{ event.id }}">&times;</button>
    </div>
    <form method="post" action="{{ url_for('update_event', event_id=event.id) }}" data-event-form data-scope="{{ event.id }}">
      <div class="field-inline" style="margin: 0.4rem 0;">
        <label><input type="checkbox" name="kassensystem_enabled" {% if event.kassensystem_enabled %}checked{% endif %}> Kassensystem aktiv</label>
        <label><input type="checkbox" name="shotcounter_enabled" {% if event.shotcounter_enabled %}checked{% endif %}> Shotcounter aktiv</label>
      </div>
      <div class="field-inline" style="margin: 0.6rem 0;">
        <label><input type="checkbox" name="auto_reload_on_add" {% if event.shared_settings and event.shared_settings.get('auto_reload_on_add', True) %}checked{% endif %} data-shared-setting> Auto-Reload beim Hinzufügen (Kasse)</label>
      </div>
      <div class="muted" style="margin-bottom: 0.6rem;">Wenn deaktiviert, wird die Kasse nicht neu geladen beim Hinzufügen von Artikeln (performanter).</div>

      {% if events|length > 1 %}
      <div class="stack" style="margin:0.6rem 0;">
        <label>Einstellungen aus Event kopieren</label>
        <div class="field-inline">
          <select data-copy-select>
            <option value="">Bitte wählen</option>
            {% for template in events if template.id != event.id %}
              <option value="{{ template.id }}">{{ template.name }}</option>
            {% endfor %}
          </select>
          <button type="button" class="secondary" data-copy-btn>Übernehmen</button>
          <span class="pill">kopiert auch Produkte</span>
        </div>
      </div>
      {% endif %}

      <input type="hidden" name="shared_settings" value='{{ (event.shared_settings or {}) | tojson }}'>

      <div
        class="shot-settings"
        data-shot-settings
        data-defaults='{{ shotcounter_defaults | tojson }}'
        data-current='{{ (shot_settings_map.get(event.id) or shotcounter_defaults) | tojson }}'
      >
        <strong>Shotcounter Styling</strong>
        <div class="muted">Steuert Vollbild/Touch: Farben, Schriftgrößen und Teamanzahl.</div>
        <div class="shot-settings__grid">
          <label class="stack">
            <span>Hintergrund</span>
            <input type="color" class="color-input" data-shot-field="background_color">
          </label>
          <label class="stack">
            <span>Primärfarbe (Karten)</span>
            <input type="color" class="color-input" data-shot-field="primary_color">
          </label>
          <label class="stack">
            <span>Sekundärfarbe (Verlauf)</span>
            <input type="color" class="color-input" data-shot-field="secondary_color">
          </label>
          <label class="stack">
            <span>Terziärfarbe (Verlauf)</span>
            <input type="color" class="color-input" data-shot-field="tertiary_color">
          </label>
        </div>
        <div class="shot-settings__numbers">
          <label class="stack">
            <span>Schriftgröße Titel (rem)</span>
            <input type="number" step="0.1" min="0.5" max="10" data-shot-field="title_size">
          </label>
          <label class="stack">
            <span>Schriftgröße Teams (rem)</span>
            <input type="number" step="0.1" min="0.5" max="10" data-shot-field="team_size">
          </label>
          <label class="stack">
            <span>Teams im Leaderboard</span>
            <input type="number" step="1" min="1" max="50" data-shot-field="leaderboard_limit">
          </label>
        </div>
        <div class="shot-settings__numbers" style="margin-top: 0.6rem;">
          <label class="stack">
            <span>Leaderboard Layout</span>
            <select data-shot-field="leaderboard_layout">
              <option value="stacked">Teamname + Shots (2 Zeilen)</option>
              <option value="inline">Teamname – Shots (1 Zeile)</option>
            </select>
          </label>
        </div>
        
        <!-- Background Image Upload -->
        <div style="margin-top: 1rem; padding-top: 1rem; border-top: 1px solid var(--border);">
          <strong>Hintergrundbild</strong>
          <div class="muted">Optional: Bild als Hintergrund für die Leaderboard-Anzeige hochladen.</div>
          {% set current_bg = shot_settings_map.get(event.id, {}).get('background_image') %}
          {% if current_bg %}
            <div style="margin-top: 0.6rem; display: flex; align-items: center; gap: 0.75rem; flex-wrap: wrap;">
              <img src="{{ url_for('uploaded_file', filename=current_bg) }}" alt="Aktuelles Hintergrundbild" style="max-width: 200px; max-height: 120px; border-radius: 8px; border: 1px solid var(--border);">
              <button
                type="submit"
                class="danger"
                form="bg-delete-{{ event.id }}"
                onclick="return confirm('Hintergrundbild wirklich entfernen?');"
              >Bild entfernen</button>
            </div>
          {% endif %}
          <div style="margin-top: 0.6rem;">
            <div class="field-inline">
              <input
                type="file"
                name="background_image"
                accept="image/png,image/jpeg,image/gif,image/webp"
                style="max-width: 300px;"
                form="bg-upload-{{ event.id }}"
              >
              <button type="submit" form="bg-upload-{{ event.id }}">Hochladen</button>
            </div>
            <div class="muted" style="margin-top: 0.3rem;">Erlaubte Formate: PNG, JPG, GIF, WebP. Max. 5 MB.</div>
          </div>
        </div>
        
        <input type="hidden" name="shotcounter_settings" value='{{ (shot_settings_map.get(event.id) or shotcounter_defaults) | tojson }}'>
      </div>

      <div class="product-editor" data-product-editor data-scope="{{ event.id }}" data-items='{{ event_buttons.get(event.id, default_buttons) | tojson }}'>
        <div class="product-editor__top">
          <div>
            <strong>Produkte für dieses Event</strong>
            <div class="muted">Titel, Preis, Farbe bearbeiten. Reihenfolge per Drag & Drop ändern.</div>
          </div>
          <div class="inline-actions">
            <label class="secondary" style="padding:0.45rem 0.65rem; cursor:pointer;">
              JSON importieren
              <input type="file" accept="application/json" data-product-import hidden>
            </label>
            <button type="button" class="secondary" data-product-export>Daten exportieren</button>
            <button type="button" class="secondary" data-add-product>+ Produkt</button>
          </div>
        </div>
        <div class="product-editor__preview" data-product-preview></div>
        <div class="product-editor__list" data-product-list></div>
        <input type="hidden" name="kassensystem_settings" value='{{ kass_settings.get(event.id, {"items": event_buttons.get(event.id, default_buttons)}) | tojson }}'>
      </div>

      <div class="field-inline" style="margin-top:0.8rem;">
        <label class="secondary" style="padding:0.45rem 0.65rem; cursor:pointer;">
          Event-JSON importieren
          <input type="file" accept="application/json" data-import-event hidden>
        </label>
        <button type="button" class="secondary" data-export-event>Event-JSON exportieren</button>
        <span class="muted">Import ersetzt die Felder oben, JSON bleibt optional.</span>
      </div>
      <div class="form-actions" style="margin-top: 1rem;">
        <button type="submit" class="primary" data-submit-btn>Speichern</button>
        <span class="form-status" data-form-status style="margin-left: 0.8rem; color: #94a3b8; display: none;"></span>
      </div>
    </form>
    <form id="bg-upload-{{ event.id }}" method="post" action="{{ url_for('upload_background', event_id=event.id) }}" enctype="multipart/form-data"></form>
    <form id="bg-delete-{{ event.id }}" method="post" action="{{ url_for('upload_background', event_id=event.id) }}">
      <input type="hidden" name="delete_background" value="1">
    </form>
  </div>
</div>
{% endfor %}


<script id="event-settings-data" type="application/json">
  {{ event_payloads | tojson }}
</script>
<script id="default-buttons-data" type="application/json">
  {{ default_buttons | tojson }}
</script>
<script id="shotcounter-defaults-data" type="application/json">
  {{ shotcounter_defaults | tojson }}
</script>

<script>
  (function () {
    try {
    // Modal functionality
    const openModal = (modalId) => {
      const modal = document.getElementById(modalId);
      if (modal) {
        modal.classList.add('active');
        document.body.classList.add('modal-open');
      }
    };

    const closeModal = (modalId) => {
      const modal = document.getElementById(modalId);
      if (modal) {
        modal.classList.remove('active');
        document.body.classList.remove('modal-open');
      }
    };

    // Open new event modal
    const newEventBtn = document.getElementById('new-event-btn');
    if (newEventBtn) {
      newEventBtn.addEventListener('click', () => openModal('new-event-modal'));
    }

    // Open event settings modals
    document.querySelectorAll('[data-event-settings]').forEach(btn => {
      btn.addEventListener('click', () => {
        const eventId = btn.getAttribute('data-event-settings');
        openModal(`event-modal-${eventId}`);
      });
    });

    // Close modals
    document.querySelectorAll('[data-close-modal]').forEach(btn => {
      btn.addEventListener('click', () => {
        const modalId = btn.getAttribute('data-close-modal');
        closeModal(modalId);
      });
    });

    // Close modal when clicking outside
    document.querySelectorAll('.modal').forEach(modal => {
      modal.addEventListener('click', (e) => {
        if (e.target.classList.contains('modal')) {
          closeModal(modal.id);
        }
      });
    });

    // Close modal on escape key
    document.addEventListener('keydown', (e) => {
      if (e.key === 'Escape') {
        document.querySelectorAll('.modal.active').forEach(modal => {
          closeModal(modal.id);
        });
      }
    });

    const fallbackColor = "#1f2a44";
    const defaultCategory = "Standard";

    const getTextContent = (id) => {
      const el = document.getElementById(id);
      return el ? el.textContent : "";
    };

    const parseJson = (value, fallback) => {
      if (!value) return fallback;
      try { return JSON.parse(value); } catch (err) { return fallback; }
    };

    const eventData = parseJson(getTextContent("event-settings-data"), {});
    const defaultButtons = parseJson(getTextContent("default-buttons-data"), []);
    const shotDefaults = parseJson(
      getTextContent("shotcounter-defaults-data"),
      {
        background_color: "#0b1222",
        primary_color: "#1e293b",
        secondary_color: "#38bdf8",
        tertiary_color: "#34d399",
        title_size: 3.2,
        team_size: 1.6,
        leaderboard_limit: 10,
      }
    );

    document.querySelectorAll("[data-collapsible]").forEach((wrap) => {
      const content = wrap.querySelector(".collapsible__content");
      const toggle = wrap.querySelector("[data-toggle]");
      if (!content || !toggle) return;
      const startOpen = wrap.dataset.startOpen === "true";
      if (startOpen) content.hidden = false;
      const syncLabel = () => { toggle.textContent = content.hidden ? "Details einblenden" : "Details ausblenden"; };
      syncLabel();
      toggle.addEventListener("click", () => { content.hidden = !content.hidden; syncLabel(); });
    });

    const sanitizeColor = (value) => {
      if (typeof value !== "string") return fallbackColor;
      const hex = value.trim();
      return /^#([0-9a-fA-F]{6}|[0-9a-fA-F]{3})$/.test(hex) ? hex : fallbackColor;
    };

    const clampNumber = (value, fallback, min, max) => {
      const parsed = Number(value);
      if (!Number.isFinite(parsed)) return fallback;
      return Math.min(max, Math.max(min, parsed));
    };

    const normalizeItem = (item, index) => {
      const safeItem = item || {};
      const label = (safeItem.label || safeItem.name || "").trim() || "Produkt " + (index + 1);
      const name = (safeItem.name || label || "produkt-" + (index + 1)).trim();
      const price = Number.isFinite(Number(safeItem.price)) ? Number(safeItem.price) : 0;
      return {
        name,
        label,
        price,
        css_class: safeItem.css_class || "custom",
        color: sanitizeColor(safeItem.color || ""),
        category: safeItem.category || defaultCategory,
      };
    };

    // Shotcounter-Settings
    document.querySelectorAll("[data-shot-settings]").forEach((wrapper) => {
      const hidden = wrapper.querySelector('input[name="shotcounter_settings"]');
      const defaults = { ...shotDefaults, ...parseJson(wrapper.dataset.defaults, shotDefaults) };
      const current = parseJson(wrapper.dataset.current, {});
      let settings = { ...defaults, ...current };

      const syncInputs = () => {
        wrapper.querySelectorAll("[data-shot-field]").forEach((input) => {
          const key = input.dataset.shotField;
          if (!key) return;
          if (input.type === "color") {
            input.value = sanitizeColor(settings[key] || defaults[key] || fallbackColor);
          } else if (input.type === "number") {
            input.value = settings[key] ?? defaults[key] ?? "";
          } else if (input.tagName === "SELECT") {
            input.value = settings[key] ?? defaults[key] ?? "";
          }
        });
      };

      const syncHidden = () => {
        if (hidden) hidden.value = JSON.stringify(settings);
      };

      wrapper.querySelectorAll("[data-shot-field]").forEach((input) => {
        const key = input.dataset.shotField;
        if (!key) return;
        input.addEventListener("input", () => {
          if (input.type === "color") {
            settings[key] = sanitizeColor(input.value || defaults[key] || fallbackColor);
          } else if (input.type === "number") {
            const min = key === "leaderboard_limit" ? 1 : 0.5;
            const max = key === "leaderboard_limit" ? 50 : 10;
            settings[key] = clampNumber(input.value, defaults[key], min, max);
          } else if (input.tagName === "SELECT") {
            settings[key] = input.value;
          }
          syncHidden();
        });
      });

      wrapper.shotSettingsApi = {
        getSettings: () => ({ ...settings }),
        setSettings: (data) => {
          settings = { ...defaults, ...(data || {}) };
          syncInputs();
          syncHidden();
        },
      };

      syncInputs();
      syncHidden();
    });

    // Produkt-Editor
    document.querySelectorAll("[data-product-editor]").forEach((wrapper) => {
      const addButton = wrapper.querySelector("[data-add-product]");
      const preview = wrapper.querySelector("[data-product-preview]");
      const list = wrapper.querySelector("[data-product-list]");
      const hidden = wrapper.querySelector('input[name="kassensystem_settings"]');
      const importInput = wrapper.querySelector("[data-product-import]");
      const exportButton = wrapper.querySelector("[data-product-export]");

      let baseSettings = {};
      try { baseSettings = JSON.parse(hidden.value || "{}"); } catch (err) { baseSettings = {}; }

      let parsedItems = [];
      try { parsedItems = JSON.parse(wrapper.dataset.items || "[]"); } catch (err) { parsedItems = []; }

      let items = Array.isArray(parsedItems) ? parsedItems.map(normalizeItem) : [];
      if (!items.length) {
        items = [normalizeItem({ name: "Produkt", label: "Neues Produkt", price: 0, color: fallbackColor }, 0)];
      }

      const syncHidden = () => {
        hidden.value = JSON.stringify({ ...baseSettings, items });
      };

      const renderPreview = () => {
        preview.innerHTML = "";
        let dragIndex = null;

        items.forEach((item, index) => {
          const card = document.createElement("div");
          card.className = "product-preview-card";
          card.draggable = true;
          card.style.background = sanitizeColor(item.color);
          card.dataset.index = index;
          card.innerHTML = `<small>${item.price} CHF</small><div style="font-weight:700;">${item.label}</div>`;

          card.addEventListener("dragstart", () => {
            dragIndex = index;
            card.classList.add("dragging");
          });
          card.addEventListener("dragend", () => card.classList.remove("dragging"));
          card.addEventListener("dragover", (ev) => {
            ev.preventDefault();
            card.classList.add("drag-over");
          });
          card.addEventListener("dragleave", () => card.classList.remove("drag-over"));
          card.addEventListener("drop", (ev) => {
            ev.preventDefault();
            card.classList.remove("drag-over");
            const targetIndex = Number(card.dataset.index);
            if (Number.isNaN(targetIndex) || dragIndex === null || dragIndex === targetIndex) {
              return;
            }
            const [moved] = items.splice(dragIndex, 1);
            items.splice(targetIndex, 0, moved);
            renderList();
            renderPreview();
            syncHidden();
          });

          preview.appendChild(card);
        });
      };

      const getAllCategories = () => {
        // Collect unique categories from all items in current editor
        const categories = new Set();
        categories.add(defaultCategory); // Always include default
        items.forEach(item => {
          if (item.category && item.category.trim()) {
            categories.add(item.category.trim());
          }
        });
        return Array.from(categories).sort();
      };

      const renderList = () => {
        list.innerHTML = "";
        
        // Create a single datalist for all category inputs in this editor
        const datalistId = `categories-datalist-${wrapper.dataset.scope || Date.now()}`;
        const datalist = document.createElement("datalist");
        datalist.id = datalistId;
        
        // Populate datalist with unique categories
        const categories = getAllCategories();
        categories.forEach(cat => {
          const option = document.createElement("option");
          option.value = cat;
          datalist.appendChild(option);
        });
        list.appendChild(datalist);

        items.forEach((item, index) => {
          const row = document.createElement("div");
          row.className = "product-row";

          const nameContainer = document.createElement("div");
          nameContainer.className = "stack";
          const nameLabel = document.createElement("label");
          nameLabel.textContent = "Schlüssel (interner Name)";
          const nameInput = document.createElement("input");
          nameInput.value = item.name;
          nameInput.placeholder = "unique-key";
          nameInput.addEventListener("input", () => {
            item.name = nameInput.value.trim();
            syncHidden();
          });
          nameContainer.append(nameLabel, nameInput);

          const labelContainer = document.createElement("div");
          labelContainer.className = "stack";
          const labelLabel = document.createElement("label");
          labelLabel.textContent = "Titel (Anzeige)";
          const labelInput = document.createElement("input");
          labelInput.value = item.label;
          labelInput.placeholder = "z.B. Bier";
          labelInput.addEventListener("input", () => {
            item.label = labelInput.value;
            if (!item.name.trim()) {
              item.name = labelInput.value;
              nameInput.value = item.name;
            }
            renderPreview();
            syncHidden();
          });
          labelContainer.append(labelLabel, labelInput);

          const priceContainer = document.createElement("div");
          priceContainer.className = "stack";
          const priceLabel = document.createElement("label");
          priceLabel.textContent = "Preis (CHF)";
          const priceInput = document.createElement("input");
          priceInput.type = "number";
          priceInput.step = "1";
          priceInput.value = item.price;
          priceInput.addEventListener("input", () => {
            const parsed = Number(priceInput.value);
            item.price = Number.isFinite(parsed) ? parsed : 0;
            renderPreview();
            syncHidden();
          });
          priceContainer.append(priceLabel, priceInput);

          const colorContainer = document.createElement("div");
          colorContainer.className = "stack";
          const colorLabel = document.createElement("label");
          colorLabel.textContent = "Hintergrundfarbe";
          const colorInput = document.createElement("input");
          colorInput.type = "color";
          colorInput.className = "color-input";
          colorInput.value = sanitizeColor(item.color);
          colorInput.addEventListener("input", () => {
            item.color = sanitizeColor(colorInput.value);
            renderPreview();
            syncHidden();
          });
          colorContainer.append(colorLabel, colorInput);

          const categoryContainer = document.createElement("div");
          categoryContainer.className = "stack";
          const categoryLabel = document.createElement("label");
          categoryLabel.textContent = "Kategorie";
          const categoryInput = document.createElement("input");
          categoryInput.setAttribute("list", datalistId);
          categoryInput.value = item.category || defaultCategory;
          categoryInput.placeholder = "Wählen oder neue Kategorie eingeben";
          categoryInput.addEventListener("input", () => {
            item.category = categoryInput.value.trim() || defaultCategory;
            syncHidden();
          });
          categoryInput.addEventListener("change", () => {
            // Commit category selection/new entry and update datalist
            const newCategory = categoryInput.value.trim() || defaultCategory;
            item.category = newCategory;
            syncHidden();

            if (newCategory && newCategory !== defaultCategory) {
              const categories = getAllCategories();
              if (!categories.includes(newCategory)) {
                // Re-render list to update datalist with new category
                renderList();
              }
            }
          });
          categoryContainer.append(categoryLabel, categoryInput);

          const actions = document.createElement("div");
          actions.className = "row-actions";
          const removeBtn = document.createElement("button");
          removeBtn.type = "button";
          removeBtn.className = "danger";
          removeBtn.textContent = "Entfernen";
          removeBtn.addEventListener("click", () => {
            items.splice(index, 1);
            if (!items.length) {
              items.push(normalizeItem({ name: "produkt", label: "Produkt", price: 0, color: fallbackColor }, 0));
            }
            renderList();
            renderPreview();
            syncHidden();
          });
          actions.appendChild(removeBtn);

          row.append(labelContainer, nameContainer, priceContainer, colorContainer, categoryContainer, actions);
          list.appendChild(row);
        });
      };

      if (addButton) {
        addButton.addEventListener("click", () => {
          items.push(
            normalizeItem(
              {
                name: "produkt-" + Date.now(),
                label: "Neues Produkt",
                price: 0,
                color: fallbackColor,
              },
              items.length
            )
          );
          renderList();
          renderPreview();
          syncHidden();
        });
      }

      if (importInput) {
        importInput.addEventListener("change", (ev) => {
          const file = ev.target.files && ev.target.files[0];
          if (!file) return;
          const reader = new FileReader();
          reader.onload = () => {
            const data = parseJson(reader.result, {});
            const importedItems = Array.isArray(data && data.items) ? data.items : Array.isArray(data) ? data : [];
            baseSettings = data && typeof data === "object" && !Array.isArray(data) ? { ...data } : {};
            items = (importedItems || []).map((it, idx) => normalizeItem(it, idx));
            if (!items.length) items = [normalizeItem({ name: "Produkt", label: "Neues Produkt", price: 0, color: fallbackColor }, 0)];
            renderList();
            renderPreview();
            syncHidden();
          };
          reader.readAsText(file);
        });
      }

      if (exportButton) {
        exportButton.addEventListener("click", () => {
          const blob = new Blob([hidden.value || "{}"], { type: "application/json" });
          const url = URL.createObjectURL(blob);
          const a = document.createElement("a");
          a.href = url;
          a.download = "produkte.json";
          a.click();
          URL.revokeObjectURL(url);
        });
      }

      wrapper.productApi = {
        getSettings: () => parseJson(hidden.value, { items: items }),
        setSettings: (data) => {
          const importedItems = Array.isArray(data && data.items) ? data.items : [];
          baseSettings = data && typeof data === "object" && !Array.isArray(data) ? { ...data } : {};
          items = importedItems.length ? importedItems.map((it, idx) => normalizeItem(it, idx)) : [normalizeItem({ name: "Produkt", label: "Produkt", price: 0, color: fallbackColor }, 0)];
          renderList();
          renderPreview();
          syncHidden();
        },
      };

      renderList();
      renderPreview();
      syncHidden();
    });

    const collectSnapshot = (form) => {
      const sharedInput = form.querySelector('input[name="shared_settings"]');
      const shotInput = form.querySelector('input[name="shotcounter_settings"]');
      const productEditor = form.querySelector("[data-product-editor]");
      const shotSettingsWrapper = form.querySelector("[data-shot-settings]");
      return {
        kassensystem_enabled: Boolean((form.querySelector('[name="kassensystem_enabled"]') || {}).checked),
        shotcounter_enabled: Boolean((form.querySelector('[name="shotcounter_enabled"]') || {}).checked),
        shared_settings: parseJson(sharedInput ? sharedInput.value : "", {}),
        shotcounter_settings:
          (shotSettingsWrapper && shotSettingsWrapper.shotSettingsApi && shotSettingsWrapper.shotSettingsApi.getSettings()) ||
          parseJson(shotInput ? shotInput.value : "", {}),
        kassensystem_settings:
          (productEditor && productEditor.productApi && productEditor.productApi.getSettings()) ||
          parseJson((form.querySelector('input[name="kassensystem_settings"]') || {}).value, {}),
      };
    };

    const applySnapshot = (form, snapshot) => {
      const kassCheck = form.querySelector('[name="kassensystem_enabled"]');
      const shotCheck = form.querySelector('[name="shotcounter_enabled"]');
      if (kassCheck) kassCheck.checked = Boolean(snapshot.kassensystem_enabled);
      if (shotCheck) shotCheck.checked = Boolean(snapshot.shotcounter_enabled);

      const sharedHidden = form.querySelector('input[name="shared_settings"]');
      const shotHidden = form.querySelector('input[name="shotcounter_settings"]');
      if (sharedHidden) sharedHidden.value = JSON.stringify(snapshot.shared_settings || {});
      if (shotHidden) shotHidden.value = JSON.stringify(snapshot.shotcounter_settings || {});
      
      // Apply shared settings checkboxes
      const autoReloadCheckbox = form.querySelector('input[name="auto_reload_on_add"]');
      if (autoReloadCheckbox && snapshot.shared_settings) {
        autoReloadCheckbox.checked = snapshot.shared_settings.auto_reload_on_add !== false; // default to true
      }

      const productEditor = form.querySelector("[data-product-editor]");
      const kassInput = form.querySelector('input[name="kassensystem_settings"]');
      const shotSettingsWrapper = form.querySelector("[data-shot-settings]");
      if (shotSettingsWrapper && shotSettingsWrapper.shotSettingsApi) {
        shotSettingsWrapper.shotSettingsApi.setSettings(snapshot.shotcounter_settings || {});
      }
      if (productEditor && productEditor.productApi) {
        productEditor.productApi.setSettings(snapshot.kassensystem_settings || { items: defaultButtons });
      } else if (kassInput) {
        kassInput.value = JSON.stringify(snapshot.kassensystem_settings || { items: defaultButtons });
      }
    };

    const bindCopyAndImport = (form) => {
      const select = form.querySelector("[data-copy-select]");
      const copyBtn = form.querySelector("[data-copy-btn]");
      const importTrigger = form.querySelector("[data-import-event]");
      const exportBtn = form.querySelector("[data-export-event]");

      if (copyBtn) {
        copyBtn.addEventListener("click", () => {
          const selectedId = select ? select.value : null;
          if (!selectedId || !eventData[selectedId]) return;
          applySnapshot(form, eventData[selectedId]);
        });
      }

      if (exportBtn) {
        exportBtn.addEventListener("click", () => {
          const data = collectSnapshot(form);
          const blob = new Blob([JSON.stringify(data, null, 2)], { type: "application/json" });
          const url = URL.createObjectURL(blob);
          const a = document.createElement("a");
          a.href = url;
          a.download = "event-settings.json";
          a.click();
          URL.revokeObjectURL(url);
        });
      }

      if (importTrigger) {
        importTrigger.addEventListener("change", (ev) => {
          const file = ev.target.files && ev.target.files[0];
          if (!file) return;
          const reader = new FileReader();
          reader.onload = () => {
            const data = parseJson(reader.result, null);
            if (!data) return;
            applySnapshot(form, {
              kassensystem_enabled: data.kassensystem_enabled !== undefined ? data.kassensystem_enabled : true,
              shotcounter_enabled: data.shotcounter_enabled !== undefined ? data.shotcounter_enabled : true,
              shared_settings: data.shared_settings || {},
              shotcounter_settings: data.shotcounter_settings || {},
              kassensystem_settings: data.kassensystem_settings || { items: defaultButtons },
            });
          };
          reader.readAsText(file);
        });
      }
    };

    document.querySelectorAll("[data-event-form]").forEach((form) => {
      bindCopyAndImport(form);
      
      // Ensure submit button works properly
      const submitBtn = form.querySelector('[data-submit-btn]');
      if (submitBtn) {
        submitBtn.addEventListener('click', function(e) {
          // Let the button naturally submit the form
          // This click handler is just to ensure the form is properly prepared
          const statusEl = form.querySelector('[data-form-status]');
          
          // Validate product names are unique before submission
          const productEditor = form.querySelector('[data-product-editor]');
          if (productEditor && productEditor.productApi) {
            const settings = productEditor.productApi.getSettings();
            const items = settings.items || [];
            const names = items.map(item => item.name);
            const duplicates = names.filter((name, index) => names.indexOf(name) !== index);
            
            if (duplicates.length > 0) {
              e.preventDefault();
              e.stopPropagation();
              if (statusEl) {
                statusEl.style.display = 'inline';
                statusEl.style.color = '#ef4444';
                statusEl.textContent = `Fehler: Doppelte Produktnamen gefunden: ${duplicates.join(', ')}`;
                setTimeout(() => {
                  statusEl.style.display = 'none';
                }, 5000);
              }
              alert(`Fehler: Doppelte Produktnamen gefunden: ${duplicates.join(', ')}`);
              return false;
            }
          }
        });
      }
      
      // Add submit handler to collect shared settings from checkboxes and show loading state
      form.addEventListener('submit', function(e) {
        const submitBtn = this.querySelector('[data-submit-btn]');
        const statusEl = this.querySelector('[data-form-status]');
        
        // Show loading state
        if (submitBtn) {
          submitBtn.disabled = true;
          const originalText = submitBtn.textContent;
          submitBtn.textContent = 'Speichere...';
          submitBtn.dataset.originalText = originalText;
        }
        if (statusEl) {
          statusEl.style.display = 'inline';
          statusEl.style.color = '#94a3b8';
          statusEl.textContent = 'Daten werden gespeichert...';
        }
        
        // Collect shared settings
        const sharedInput = this.querySelector('input[name="shared_settings"]');
        if (sharedInput) {
          const currentSettings = parseJson(sharedInput.value, {});
          
          // Collect all checkboxes with data-shared-setting attribute
          const autoReloadCheckbox = this.querySelector('input[name="auto_reload_on_add"]');
          if (autoReloadCheckbox) {
            currentSettings.auto_reload_on_add = autoReloadCheckbox.checked;
          }
          
          sharedInput.value = JSON.stringify(currentSettings);
        }
        
        // Form will now submit naturally
      });
    });

    const credentialsForm = document.querySelector("[data-credentials-form]");
    if (credentialsForm) {
      const errorBox = credentialsForm.querySelector("[data-credentials-error]");
      const usernameInput = credentialsForm.querySelector("#admin_username");
      const passwordInput = credentialsForm.querySelector("#admin_password");
      const hasPassword = credentialsForm.dataset.hasPassword === "true";

      const showError = (message) => {
        if (!errorBox) return;
        errorBox.textContent = message;
        errorBox.style.display = "block";
      };

      const clearError = () => {
        if (!errorBox) return;
        errorBox.textContent = "";
        errorBox.style.display = "none";
      };

      credentialsForm.addEventListener("submit", (event) => {
        const username = usernameInput ? usernameInput.value.trim() : "";
        const password = passwordInput ? passwordInput.value : "";

        if (!username) {
          event.preventDefault();
          showError("Benutzername darf nicht leer sein.");
          return;
        }

        if (!hasPassword && !password) {
          event.preventDefault();
          showError("Bitte ein Passwort setzen, damit der Admin-Bereich geschützt ist.");
          return;
        }

        if (password && password.length < 8) {
          event.preventDefault();
          showError("Passwort muss mindestens 8 Zeichen lang sein.");
          return;
        }

        clearError();
      });
    }
    } catch (err) {
      console.error("Admin UI Init Error", err);
      document.querySelectorAll(".collapsible__content").forEach((content) => {
        content.hidden = false;
      });
    }

    // Network Management UI
    const loadNetworkStatus = async () => {
      const container = document.getElementById('network-status');
      if (!container) return;

      try {
        const response = await fetch('/admin/network');
        const data = await response.json();
        
        let html = '<div style="display: grid; gap: 1.5rem;">';
        
        // LAN (eth0) Section
        html += '<div class="stack">';
        html += '<h3 style="margin: 0; color: #cbd5e1;">LAN Interface (eth0)</h3>';
        if (data.eth0.exists) {
          html += '<div style="background: rgba(255,255,255,0.04); padding: 1rem; border-radius: 8px; border: 1px solid var(--border);">';
          html += `<div class="field-inline" style="margin-bottom: 0.5rem;"><strong>IP-Adresse:</strong> <span>${data.eth0.ip || 'N/A'}</span></div>`;
          html += `<div class="field-inline" style="margin-bottom: 0.5rem;"><strong>Subnetzmaske:</strong> <span>${data.eth0.netmask || 'N/A'}</span></div>`;
          html += `<div class="field-inline"><strong>Status:</strong> <span class="badge ${data.eth0.status === 'up' ? 'badge-green' : 'badge-red'}">${data.eth0.status}</span></div>`;
          html += '</div>';
        } else {
          html += '<p class="muted">Interface nicht gefunden</p>';
        }
        html += '</div>';
        
        // WLAN (wlan0) Section
        html += '<div class="stack">';
        html += '<h3 style="margin: 0; color: #cbd5e1;">WLAN Interface (wlan0)</h3>';
        if (data.wlan0.exists) {
          html += '<div style="background: rgba(255,255,255,0.04); padding: 1rem; border-radius: 8px; border: 1px solid var(--border);">';
          html += `<div class="field-inline" style="margin-bottom: 0.5rem;"><strong>IP-Adresse:</strong> <span>${data.wlan0.ip || 'Nicht verbunden'}</span></div>`;
          html += `<div class="field-inline" style="margin-bottom: 0.5rem;"><strong>SSID:</strong> <span>${data.wlan0.ssid || 'Nicht verbunden'}</span></div>`;
          if (data.wlan0.signal_level) {
            html += `<div class="field-inline" style="margin-bottom: 0.5rem;"><strong>Signalstärke:</strong> <span>${data.wlan0.signal_level}</span></div>`;
          }
          html += `<div class="field-inline"><strong>Status:</strong> <span class="badge ${data.wlan0.status === 'up' ? 'badge-green' : 'badge-red'}">${data.wlan0.status}</span></div>`;
          html += '</div>';
          
          // WiFi Connect Form
          html += '<div style="margin-top: 1rem; padding: 1rem; background: rgba(255,255,255,0.02); border: 1px dashed var(--border); border-radius: 8px;">';
          html += '<h4 style="margin: 0 0 0.8rem 0;">Neues WLAN verbinden</h4>';
          html += '<form id="wifi-connect-form">';
          html += '<div class="stack" style="margin-bottom: 0.8rem;">';
          html += '<label>SSID (Netzwerkname)</label>';
          html += '<input type="text" name="ssid" required placeholder="Netzwerkname eingeben">';
          html += '</div>';
          html += '<div class="stack" style="margin-bottom: 0.8rem;">';
          html += '<label>Passwort</label>';
          html += '<input type="password" name="password" placeholder="Passwort (min. 8 Zeichen)">';
          html += '</div>';
          html += '<div class="field-inline">';
          html += '<button type="submit">Verbinden</button>';
          html += '<button type="button" onclick="scanWifi()" class="secondary">Netzwerke scannen</button>';
          html += '</div>';
          html += '<div id="wifi-connect-message" style="margin-top: 0.8rem;"></div>';
          html += '</form>';
          html += '<div id="wifi-scan-results" style="margin-top: 1rem;"></div>';
          html += '</div>';
        } else {
          html += '<p class="muted">Interface nicht gefunden</p>';
        }
        html += '</div>';
        
        // DHCP Leases Section
        html += '<div class="stack">';
        html += '<h3 style="margin: 0; color: #cbd5e1;">Verbundene Clients (DHCP)</h3>';
        if (data.dhcp_leases && data.dhcp_leases.length > 0) {
          html += '<div style="background: rgba(255,255,255,0.04); padding: 1rem; border-radius: 8px; border: 1px solid var(--border);">';
          html += '<table style="width: 100%; border-collapse: collapse;">';
          html += '<thead><tr style="border-bottom: 1px solid var(--border);"><th style="text-align: left; padding: 0.5rem;">IP</th><th style="text-align: left; padding: 0.5rem;">MAC</th><th style="text-align: left; padding: 0.5rem;">Hostname</th></tr></thead>';
          html += '<tbody>';
          data.dhcp_leases.forEach(lease => {
            html += `<tr style="border-bottom: 1px solid rgba(255,255,255,0.05);"><td style="padding: 0.5rem;">${lease.ip}</td><td style="padding: 0.5rem; font-family: monospace;">${lease.mac}</td><td style="padding: 0.5rem;">${lease.hostname}</td></tr>`;
          });
          html += '</tbody></table>';
          html += '</div>';
        } else {
          html += '<p class="muted">Keine verbundenen Clients</p>';
        }
        html += '</div>';
        
        html += '</div>';
        
        container.innerHTML = html;
        
        // Attach WiFi connect handler
        const wifiForm = document.getElementById('wifi-connect-form');
        if (wifiForm) {
          wifiForm.addEventListener('submit', async (e) => {
            e.preventDefault();
            const formData = new FormData(e.target);
            const messageDiv = document.getElementById('wifi-connect-message');
            messageDiv.innerHTML = '<p class="muted">Verbinde...</p>';
            
            try {
              const response = await fetch('/admin/network/wifi/connect', {
                method: 'POST',
                body: formData
              });
              const result = await response.json();
              
              if (result.success) {
                messageDiv.innerHTML = `<p style="color: #10b981;">${result.message}</p>`;
                setTimeout(() => loadNetworkStatus(), 5000);
              } else {
                messageDiv.innerHTML = `<p style="color: #ef4444;">Fehler: ${result.error}</p>`;
              }
            } catch (error) {
              messageDiv.innerHTML = `<p style="color: #ef4444;">Fehler: ${error.message}</p>`;
            }
          });
        }
      } catch (error) {
        container.innerHTML = `<p style="color: #ef4444;">Fehler beim Laden: ${error.message}</p>`;
      }
    };

    window.scanWifi = async () => {
      const resultsDiv = document.getElementById('wifi-scan-results');
      if (!resultsDiv) return;
      
      resultsDiv.innerHTML = '<p class="muted">Scanne nach Netzwerken...</p>';
      
      try {
        const response = await fetch('/admin/network/wifi/scan');
        const data = await response.json();
        
        if (data.success && data.networks.length > 0) {
          let html = '<h4 style="margin: 0.8rem 0;">Verfügbare Netzwerke</h4>';
          html += '<div style="display: flex; flex-direction: column; gap: 0.5rem;">';
          data.networks.forEach(network => {
            const escapedSsid = network.ssid.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;').replace(/'/g, '&#39;');
            const ssidForJs = network.ssid.replace(/\\/g, '\\\\').replace(/'/g, "\\'").replace(/"/g, '\\"');
            html += `<div style="padding: 0.6rem; background: rgba(255,255,255,0.04); border: 1px solid var(--border); border-radius: 6px; cursor: pointer;" onclick="document.querySelector('input[name=ssid]').value='${ssidForJs}'"}>`;
            html += `<div style="display: flex; justify-content: space-between; align-items: center;">`;
            html += `<strong>${escapedSsid}</strong>`;
            html += `<div style="display: flex; gap: 0.5rem; align-items: center;">`;
            html += `<span class="pill">${network.encryption}</span>`;
            html += `<span class="muted" style="font-size: 0.85rem;">${network.quality}%</span>`;
            html += `</div></div></div>`;
          });
          html += '</div>';
          resultsDiv.innerHTML = html;
        } else {
          resultsDiv.innerHTML = '<p class="muted">Keine Netzwerke gefunden</p>';
        }
      } catch (error) {
        resultsDiv.innerHTML = `<p style="color: #ef4444;">Fehler: ${error.message}</p>`;
      }
    };

    // Git Status UI
    const loadGitStatus = async () => {
      const container = document.getElementById('git-status');
      if (!container) return;

      try {
        const response = await fetch('/admin/system/git-status');
        let data;
        const ct = (response.headers.get('content-type') || '').toLowerCase();
        if (ct.includes('application/json')) {
          data = await response.json();
        } else {
          const text = await response.text();
          throw new Error(`Unerwartete Server-Antwort: ${text}`);
        }
        
        let html = '<div class="stack">';
        html += '<div style="background: rgba(255,255,255,0.04); padding: 1rem; border-radius: 8px; border: 1px solid var(--border);">';
        html += `<div class="field-inline" style="margin-bottom: 0.5rem;"><strong>Branch:</strong> <span>${data.branch || 'N/A'}</span></div>`;
        html += `<div class="field-inline" style="margin-bottom: 0.5rem;"><strong>Commit:</strong> <span style="font-family: monospace;">${data.commit_short || 'N/A'}</span></div>`;
        html += `<div class="field-inline" style="margin-bottom: 0.5rem;"><strong>Nicht committete Änderungen:</strong> <span class="badge ${data.has_changes ? 'badge-red' : 'badge-green'}">${data.has_changes ? 'Ja' : 'Nein'}</span></div>`;
        
        if (data.behind > 0) {
          html += `<div class="field-inline"><strong>Status:</strong> <span class="badge badge-yellow">${data.behind} Commit(s) hinter Remote</span></div>`;
        } else {
          html += `<div class="field-inline"><strong>Status:</strong> <span class="badge badge-green">Aktuell</span></div>`;
        }
        html += '</div>';
        
        html += '<div style="margin-top: 1rem; padding: 1rem; background: rgba(255,255,255,0.02); border: 1px dashed var(--border); border-radius: 8px;">';
        html += '<h4 style="margin: 0 0 0.8rem 0;">Repository aktualisieren</h4>';
        html += '<p class="muted" style="margin-bottom: 0.8rem;">Lädt die neueste Version vom Git-Repository und startet den Service neu.</p>';
        
        if (data.has_changes) {
          html += '<p style="color: #f59e0b; margin-bottom: 0.8rem;"><strong>⚠️ Warnung:</strong> Es gibt nicht committete Änderungen. Update ist nicht möglich.</p>';
          html += '<button type="button" class="secondary" disabled>Update nicht möglich</button>';
        } else {
          html += '<button type="button" onclick="performGitUpdate()" class="primary">Jetzt aktualisieren</button>';
        }
        html += '<div id="git-update-message" style="margin-top: 0.8rem;"></div>';
        html += '</div>';
        
        html += '</div>';
        
        container.innerHTML = html;
      } catch (error) {
        container.innerHTML = `<p style="color: #ef4444;">Fehler beim Laden: ${error.message}</p>`;
      }
    };

    window.performGitUpdate = async () => {
      const messageDiv = document.getElementById('git-update-message');
      if (!messageDiv) return;
      
      if (!confirm('Möchten Sie wirklich das System aktualisieren? Der Service wird dabei neu gestartet.')) {
        return;
      }
      
      messageDiv.innerHTML = '<p class="muted">Update wird durchgeführt...</p>';
      
      try {
        const response = await fetch('/admin/system/git-update', {
          method: 'POST'
        });
        let result;
        const ct = (response.headers.get('content-type') || '').toLowerCase();
        if (ct.includes('application/json')) {
          result = await response.json();
        } else {
          const text = await response.text();
          messageDiv.innerHTML = `<p style="color: #ef4444;">Fehler: Unerwartete Antwort vom Server: ${text}</p>`;
          return;
        }
        
        if (result.success) {
          messageDiv.innerHTML = `<p style="color: #10b981;">${result.message}</p>`;
          setTimeout(() => {
            messageDiv.innerHTML += '<p class="muted">Seite wird in 5 Sekunden neu geladen...</p>';
            setTimeout(() => location.reload(), 5000);
          }, 2000);
        } else {
          messageDiv.innerHTML = `<p style="color: #ef4444;">Fehler: ${result.error}</p>`;
        }
      } catch (error) {
        messageDiv.innerHTML = `<p style="color: #ef4444;">Fehler: ${error.message}</p>`;
      }
    };

    // Load network and git status when sections are opened
    document.querySelectorAll('[data-collapsible]').forEach(collapsible => {
      const toggle = collapsible.querySelector('[data-toggle]');
      const content = collapsible.querySelector('.collapsible__content');
      
      if (toggle && content) {
        const originalClickHandler = toggle.onclick;
        toggle.addEventListener('click', () => {
          // Load data when section is opened
          if (content.hidden === false) {
            if (collapsible.querySelector('#network-status')) {
              loadNetworkStatus();
            } else if (collapsible.querySelector('#git-status')) {
              loadGitStatus();
            }
          }
        });
      }
    });
  })();
</script>

{% endblock %}
